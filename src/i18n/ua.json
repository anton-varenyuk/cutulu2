{
  "flyweight": "Легковаговик",
  "flyweight_disclaimer": "Легковаговик — це структурний патерн проектування, що дає змогу вмістити більшу кількість об’єктів у відведеній оперативній пам’яті. Легковаговик заощаджує пам’ять, розподіляючи спільний стан об’єктів між собою, замість зберігання однакових даних у кожному об’єкті.",
  "bridge": "Міст",
  "bridge_disclaimer": "Міст — це структурний патерн проектування, який розділяє один або кілька класів на дві окремі ієрархії — абстракцію та реалізацію, дозволяючи змінювати код в одній гілці класів, незалежно від іншої.",
  "prototype": "Прототип",
  "prototype_disclaimer": "Прототип — це породжувальний патерн проектування, що дає змогу копіювати об’єкти, не вдаючись у подробиці їхньої реалізації.",
  "composite": "Компонувальник",
  "composite_disclaimer": "Компонувальник — це структурний патерн проектування, що дає змогу згрупувати декілька об’єктів у деревоподібну структуру, а потім працювати з нею так, ніби це одиничний об’єкт.",
  "currying": "Каррінг",
  "currying_disclaimer": "Каррінг — це техніка перекладу функції, яка приймає кілька аргументів, у послідовність сімейств функцій, кожна з яких приймає один аргумент.",
  "proxy": "Замісник",
  "proxy_disclaimer": "Замісник — це структурний патерн проектування, що дає змогу підставляти замість реальних об’єктів спеціальні об’єкти-замінники. Ці об’єкти перехоплюють виклики до оригінального об’єкта, дозволяючи зробити щось до чи після передачі виклику оригіналові.",
  "chainOfResponsibility": "Ланцюжок обов'язків",
  "chainOfResponsibility_disclaimer": "Ланцюжок обов’язків — це поведінковий патерн проектування, що дає змогу передавати запити послідовно ланцюжком обробників. Кожен наступний обробник вирішує, чи може він обробити запит сам і чи варто передавати запит далі ланцюжком.",
  "visitor": "Відвідувач",
  "visitor_disclaimer": "Відвідувач — це поведінковий патерн проектування, що дає змогу додавати до програми нові операції, не змінюючи класи об’єктів, над якими ці операції можуть виконуватися.",
  "observable": "Observer",
  "observable_disclaimer": "Спостерігач — це поведінковий патерн проектування, який створює механізм підписки, що дає змогу одним об’єктам стежити й реагувати на події, які відбуваються в інших об’єктах.",
  "mediator": "Посередник",
  "mediator_disclaimer": "Посередник — це поведінковий патерн проектування, що дає змогу зменшити зв’язаність великої кількості класів між собою, завдяки переміщенню цих зв’язків до одного класу-посередника.",
  "facade": "Фасад",
  "facade_disclaimer": "Фасад — це структурний патерн проектування, який надає простий інтерфейс до складної системи класів, бібліотеки або фреймворку.",
  "decorator": "Декоратор",
  "decorator_disclaimer": "Декоратор — це структурний патерн проектування, що дає змогу динамічно додавати об’єктам нову функціональність, загортаючи їх у корисні «обгортки».",
  "builder": "Будівельник",
  "builder_disclaimer": "Будівельник — це породжувальний патерн проектування, що дає змогу створювати складні об’єкти крок за кроком. Будівельник дає можливість використовувати один і той самий код будівництва для отримання різних відображень об’єктів.",
  "abstractFactory": "Абстрактна фабрика",
  "abstractFactory_disclaimer": "Абстрактна фабрика — це породжувальний патерн проектування, що дає змогу створювати сімейства пов’язаних об’єктів, не прив’язуючись до конкретних класів створюваних об’єктів.",
  "factory": "Фабричний метод",
  "factory_disclaimer": "Фабричний метод — це породжувальний патерн проектування, який визначає загальний інтерфейс для створення об’єктів у суперкласі, дозволяючи підкласам змінювати тип створюваних об’єктів.",
  "singleton": "Одинак",
  "singleton_disclaimer": "Одинак — це породжувальний патерн проектування, який гарантує, що клас має лише один екземпляр, та надає глобальну точку доступу до нього."
}