{
  "added": "Додано",
  "flyweight": "Легковаговик",
  "flyweight_disclaimer": "Легковаговик — це структурний патерн проектування, що дає змогу вмістити більшу кількість об’єктів у відведеній оперативній пам’яті. Легковаговик заощаджує пам’ять, розподіляючи спільний стан об’єктів між собою, замість зберігання однакових даних у кожному об’єкті.",
  "bridge": "Міст",
  "bridge_disclaimer": "Міст — це структурний патерн проектування, який розділяє один або кілька класів на дві окремі ієрархії — абстракцію та реалізацію, дозволяючи змінювати код в одній гілці класів, незалежно від іншої.",
  "prototype": "Прототип",
  "prototype_disclaimer": "Прототип — це породжувальний патерн проектування, що дає змогу копіювати об’єкти, не вдаючись у подробиці їхньої реалізації.",
  "composite": "Компонувальник",
  "composite_disclaimer": "Компонувальник — це структурний патерн проектування, що дає змогу згрупувати декілька об’єктів у деревоподібну структуру, а потім працювати з нею так, ніби це одиничний об’єкт.",
  "currying": "Каррінг",
  "currying_disclaimer": "Каррінг — це техніка перекладу функції, яка приймає кілька аргументів, у послідовність сімейств функцій, кожна з яких приймає один аргумент.",
  "proxy": "Замісник",
  "proxy_disclaimer": "Замісник — це структурний патерн проектування, що дає змогу підставляти замість реальних об’єктів спеціальні об’єкти-замінники. Ці об’єкти перехоплюють виклики до оригінального об’єкта, дозволяючи зробити щось до чи після передачі виклику оригіналові.",
  "chainOfResponsibility": "Ланцюжок обов'язків",
  "chainOfResponsibility_disclaimer": "Ланцюжок обов’язків — це поведінковий патерн проектування, що дає змогу передавати запити послідовно ланцюжком обробників. Кожен наступний обробник вирішує, чи може він обробити запит сам і чи варто передавати запит далі ланцюжком.",
  "visitor": "Відвідувач",
  "visitor_disclaimer": "Відвідувач — це поведінковий патерн проектування, що дає змогу додавати до програми нові операції, не змінюючи класи об’єктів, над якими ці операції можуть виконуватися.",
  "observable": "Observer",
  "observable_disclaimer": "Спостерігач — це поведінковий патерн проектування, який створює механізм підписки, що дає змогу одним об’єктам стежити й реагувати на події, які відбуваються в інших об’єктах.",
  "mediator": "Посередник",
  "mediator_disclaimer": "Посередник — це поведінковий патерн проектування, що дає змогу зменшити зв’язаність великої кількості класів між собою, завдяки переміщенню цих зв’язків до одного класу-посередника.",
  "facade": "Фасад",
  "facade_disclaimer": "Фасад — це структурний патерн проектування, який надає простий інтерфейс до складної системи класів, бібліотеки або фреймворку.",
  "decorator": "Декоратор",
  "decorator_disclaimer": "Декоратор — це структурний патерн проектування, що дає змогу динамічно додавати об’єктам нову функціональність, загортаючи їх у корисні «обгортки».",
  "builder": "Будівельник",
  "builder_disclaimer": "Будівельник — це породжувальний патерн проектування, що дає змогу створювати складні об’єкти крок за кроком. Будівельник дає можливість використовувати один і той самий код будівництва для отримання різних відображень об’єктів.",
  "abstractFactory": "Абстрактна фабрика",
  "abstractFactory_disclaimer": "Абстрактна фабрика — це породжувальний патерн проектування, що дає змогу створювати сімейства пов’язаних об’єктів, не прив’язуючись до конкретних класів створюваних об’єктів.",
  "factory": "Фабричний метод",
  "factory_disclaimer": "Фабричний метод — це породжувальний патерн проектування, який визначає загальний інтерфейс для створення об’єктів у суперкласі, дозволяючи підкласам змінювати тип створюваних об’єктів.",
  "singleton": "Одинак",
  "singleton_disclaimer": "Одинак — це породжувальний патерн проектування, який гарантує, що клас має лише один екземпляр, та надає глобальну точку доступу до нього.",
  "hashFunction": "Хеш функція",
  "hashFunction_disclaimer": "Хеш-функція — це будь-яка функція, яка може використовуватися для зіставлення даних довільного розміру зі значеннями фіксованого розміру, хоча є деякі хеш-функції, які підтримують вивід змінної довжини.",
  "bubbleSorting": "Бульбашкове сортування",
  "bubbleSorting_disclaimer": "Бульбашкове сортування, яке іноді називають сортуванням із зануренням, — це простий алгоритм сортування, який багаторазово проходить список, який потрібно відсортувати, порівнює кожну пару суміжних елементів і міняє їх місцями, якщо вони розташовані в неправильному порядку (розташування за зростанням або спаданням). Перехід по списку повторюється до тих пір, поки не будуть потрібні заміни, що означає, що список відсортовано.",
  "insertionSorting": "Сортування вставкою",
  "insertionSorting_disclaimer": "Сортування вставкою — це простий алгоритм сортування, який створює остаточний відсортований масив (або список) по одному елементу за раз. Він набагато менш ефективний для великих списків, ніж більш просунуті алгоритми, такі як швидке сортування, сортування купою або сортування злиттям.",
  "bucketSorting": "Сортування по відрам",
  "bucketSorting_disclaimer": "Сортування по відрам, або сортування по відрах, — це алгоритм сортування, який працює шляхом розподілу елементів масиву на певну кількість відер. Потім кожне відро сортується окремо за допомогою іншого алгоритму сортування або шляхом рекурсивного застосування алгоритму сортування відра.",
  "templateMethod": "Шаблонний метод",
  "templateMethod_disclaimer": "Шаблон шаблонного методу — це шаблон поведінкового проектування, який визначає скелет алгоритму в базовому класі, але дозволяє підкласам замінювати конкретні кроки алгоритму, не змінюючи його структуру.",
  "strategy": "Стратегія",
  "strategy_disclaimer": "Стратегія — це поведінковий патерн, який виносить набір алгоритмів у власні класи і робить їх взаємозамінними."
}